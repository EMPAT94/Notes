# Learning a general-purpose language

## Beginner

### Theory

> Quick Starts, Tutorials, Walk-throughs, User Guides, Beginner Books, etc

1. Basic data types and operators
1. Basic data structures
1. Variable definition
1. Function definition
1. Loops
1. Branching
1. Some Std library

   1. Data manipulation
   1. File
   1. OS
   1. Network
   1. Datetime
   1. Math
   1. Extended data structures

> Grok the lexicon, sementics and syntax!

_Many languages have different ways of doing the same thing; many even do the same thing the same way but under a different name!_

### Practical

1. Very simple (usually single file) problems like:

   1. Fibonacci, Primes Sieve, etc
   1. Pull data from a public api and store in a file
   1. Read data from file into language-specific data structure
   1. Convert and write data into json/csv file as original backup
   1. Store data into a database
   1. Create web server routes that GET and POST a row of data in db

1. Syntactically challenging yet still easy to solve problems like:

   1. A simple game (guess the number, hangman etc)
   1. A simple management system (orders, employees, library etc)
   1. A simple data processing pipeline (calculate statistics from a transaction sheet, etc)
   1. A simple web scraper
   1. A simple to-do app
   1. A simple chat app

_Yes, we must keep in mind that the solutions need to be **SIMPLE**, else we miss the forest for the trees._

## Intermediate

### Theory

> Documentations, User Manuals, API References, More Books etc

1. Simple Project Structure (with tooling)
   1. Linters
   2. Test Runners
   3. Formatters
   4. Package Managers
1. Concurrent/Parallel (Async) Model
1. Exception Handling
1. Modules/Packages Handling
1. Higher Level Concepts (Inheritance, Protocols, Dispatchers, Composition, Type classes etc)
1. Scope/Context Model
1. Common Gotchas (Haskell string, JS falsy, Python GIL, etc)
1. Simple Macros (if they exist)
1. Pattern Matching (if it exists)
1. Regular Expression Support
1. Memory Allocation/Deallocation (if required)
1. Value/Reference/Address Passing Support
1. More from std library
1. Popular packages from public repository
1. Best practices, conventions

## Practical

1. 6 small projects
2. 3 medium projects
3. 1 large project
4. Contribute to open source projects

## Expert

> Everything, everywhere but not all at once

1. Idiomatic Code
1. Complex Project Structure (with embedded DSLs, advanced config, CI/CD, container images etc)
1. Development/Testing/Deployment workflows
1. Foreign Function Interface
1. Memory Management Models (with different GC mechanisms)
1. Performance Gotchas (tail-call recursion, lazy evaluation, etc)
1. Complex Macros and Language extension
1. When to overrule best practices and conventions

---

Ideally, should spend as little time as possible in Beginner phase. An experience programmer can pick up the basics in less than a week.

Spend most of the time in Intermediate phase, working on different projects. This is where you'll learn much of what the language has to offer.

There will be a stark contrast to moving from beginner to intermediate, as you change the scale of your projects. The same cannot be said for intermediate to expert. It could take years, and it is a very gradual process.
